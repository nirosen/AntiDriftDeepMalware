from torch import nn, Tensor, ones, exp
from torch.nn import functional as F


class ConceptDriftModel(nn.Module):
    def __init__(
        self,
        init_correctness_prob: float = 0.9,
        init_decay_rate: float = 0,
        init_noise_power: float = 0.1,
        init_nondrifting_quantile: float = 0.2,
    ):
        super().__init__()
        self.N = nn.Parameter(init_noise_power * ones(1))  # Noise power
        self.a = nn.Parameter(-init_decay_rate * ones(1))  # dynaic coefficient
        self.drifting = nn.Parameter(
            init_correctness_prob * (1 - init_nondrifting_quantile) * ones(1)
        )  # inital "corrctness" probability that's lost over time.
        self.non_drifting = nn.Parameter(
            init_correctness_prob * init_nondrifting_quantile * ones(1)
        )  # inital "corrctness" probability that stays long term.

    def forward(self, time_elapsed):
        Nt = time_elapsed * self.N
        decaying_part = Nt + self.drifting
        decay = exp(time_elapsed * self.a)
        non_decaying = self.non_drifting + Nt
        return decaying_part * decay + non_decaying


def get_beta_stats(num_correct, num_mistakes):
    a = 1 + num_correct
    b = 1 + num_mistakes
    prob_mean = a / (a +b)
    prob_std = a * b / ((a + b + 1) * ((a + b) ** 2))
    return prob_mean, prob_std

if __name__ == "__main__":
    cdm = ConceptDriftModel()
    example_result = cdm(Tensor([5]))
    # Try both BCELoss and MSELoss. Try also BCEWithLogitsLoss
